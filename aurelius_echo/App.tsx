
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { AppView, Quote, Landmark, Schedule, Coordinates } from './types';
import { fetchStoicQuote } from './services/gemini';
import { getDistanceInMeters, getCurrentPosition } from './utils/geo';
import { sendNotification } from './services/notifications';
import QuoteCard from './components/QuoteCard';
import LandmarkManager from './components/LandmarkManager';
import ScheduleManager from './components/ScheduleManager';
import Navigation from './components/Navigation';

const App: React.FC = () => {
  // -- State --
  const [currentView, setCurrentView] = useState<AppView>(AppView.HOME);
  const [quote, setQuote] = useState<Quote | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  
  // Persistent State (Initialize from localStorage)
  const [landmarks, setLandmarks] = useState<Landmark[]>(() => {
    const saved = localStorage.getItem('aurelius_landmarks');
    return saved ? JSON.parse(saved) : [];
  });

  const [schedules, setSchedules] = useState<Schedule[]>(() => {
    const saved = localStorage.getItem('aurelius_schedules');
    return saved ? JSON.parse(saved) : [];
  });

  // Quote history for variety (keep last 30 quotes)
  const [quoteHistory, setQuoteHistory] = useState<string[]>(() => {
    const saved = localStorage.getItem('aurelius_quote_history');
    return saved ? JSON.parse(saved) : [];
  });

  // -- Refs for Interval/Tracking --
  const locationWatchId = useRef<number | null>(null);

  // -- Persistence Effects --
  useEffect(() => {
    localStorage.setItem('aurelius_landmarks', JSON.stringify(landmarks));
  }, [landmarks]);

  useEffect(() => {
    localStorage.setItem('aurelius_schedules', JSON.stringify(schedules));
  }, [schedules]);

  useEffect(() => {
    localStorage.setItem('aurelius_quote_history', JSON.stringify(quoteHistory));
  }, [quoteHistory]);

  // -- Quote Handling --
  const getQuote = useCallback(async (context: string = 'General', force: boolean = false, shouldNotify: boolean = false) => {
    setIsLoading(true);
    try {
      const { quote: text, interpretation } = await fetchStoicQuote(context, quoteHistory);
      setQuote({
        text,
        interpretation,
        context,
        timestamp: Date.now()
      });

      // Update quote history (keep last 30)
      setQuoteHistory(prev => {
        const updated = [...prev, text];
        return updated.slice(-30);
      });

      // If generated by a trigger, ensure we are on the home view
      if (force) {
        setCurrentView(AppView.HOME);
      }

      // Send notification if triggered automatically
      if (shouldNotify) {
        sendNotification("Aurelius Echo", text);
      }

    } catch (error) {
      console.error("Error getting quote", error);
    } finally {
      setIsLoading(false);
    }
  }, [quoteHistory]);

  // Initial Load
  useEffect(() => {
    if (!quote) {
      const initialContexts = [
        "starting the day",
        "opening the app",
        "seeking guidance",
        "beginning a new moment",
        "looking for wisdom"
      ];
      const randomContext = initialContexts[Math.floor(Math.random() * initialContexts.length)];
      getQuote(randomContext);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // -- Landmark Trigger Logic --
  const checkLandmarks = useCallback(async (coords: Coordinates) => {
    const now = Date.now();
    const cooldown = 60 * 60 * 1000; // 1 hour cooldown per landmark

    const updatedLandmarks = landmarks.map(l => {
      const distance = getDistanceInMeters(coords, l.coords);
      // Check if within radius
      if (distance <= l.radius) {
        // Check cooldown
        if (!l.lastTriggered || (now - l.lastTriggered > cooldown)) {
          // TRIGGER!
          getQuote(`arriving at ${l.name}`, true, true);
          return { ...l, lastTriggered: now };
        }
      }
      return l;
    });

    // Only update state if changes occurred to avoid loops
    if (JSON.stringify(updatedLandmarks) !== JSON.stringify(landmarks)) {
        setLandmarks(updatedLandmarks);
    }
  }, [landmarks, getQuote]);

  // -- Location Watcher --
  useEffect(() => {
    if (!navigator.geolocation) return;

    const success = (pos: GeolocationPosition) => {
      const coords = {
        latitude: pos.coords.latitude,
        longitude: pos.coords.longitude
      };
      checkLandmarks(coords);
    };

    const error = (err: GeolocationPositionError) => {
      console.warn("Geo error:", err);
    };

    locationWatchId.current = navigator.geolocation.watchPosition(success, error, {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 5000
    });

    return () => {
      if (locationWatchId.current !== null) {
        navigator.geolocation.clearWatch(locationWatchId.current);
      }
    };
  }, [checkLandmarks]);

  // -- Schedule Trigger Logic --
  useEffect(() => {
    const interval = setInterval(() => {
      const now = new Date();
      const currentTimeString = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
      const todayDateString = now.toISOString().split('T')[0];

      let scheduleTriggered = false;
      
      const updatedSchedules = schedules.map(s => {
        if (s.time === currentTimeString && s.lastTriggeredDate !== todayDateString) {
          // TRIGGER!
          getQuote(`it is ${s.label}`, true, true);
          scheduleTriggered = true;
          return { ...s, lastTriggeredDate: todayDateString };
        }
        return s;
      });

      if (scheduleTriggered) {
        setSchedules(updatedSchedules);
      }

    }, 10000); // Check every 10 seconds

    return () => clearInterval(interval);
  }, [schedules, getQuote]);


  // -- Handlers --
  const handleAddLandmark = (l: Landmark) => setLandmarks([...landmarks, l]);
  const handleRemoveLandmark = (id: string) => setLandmarks(landmarks.filter(l => l.id !== id));
  
  const handleAddSchedule = (s: Schedule) => setSchedules([...schedules, s]);
  const handleRemoveSchedule = (id: string) => setSchedules(schedules.filter(s => s.id !== id));

  // -- Render --
  return (
    <div className="bg-stone-950 min-h-screen w-full text-stone-200 flex flex-col relative font-sans">
      
      {/* Main Content Area */}
      <main className="flex-grow w-full pb-20 overflow-hidden">
        {currentView === AppView.HOME && (
          <QuoteCard
            quote={quote}
            isLoading={isLoading}
            onRefresh={() => {
              const refreshContexts = [
                "seeking fresh wisdom",
                "looking for new perspective",
                "wanting guidance",
                "refreshing the mind",
                "asking for insight"
              ];
              const randomContext = refreshContexts[Math.floor(Math.random() * refreshContexts.length)];
              getQuote(randomContext);
            }}
          />
        )}
        
        {currentView === AppView.LANDMARKS && (
          <LandmarkManager 
            landmarks={landmarks} 
            onAddLandmark={handleAddLandmark} 
            onRemoveLandmark={handleRemoveLandmark}
          />
        )}

        {currentView === AppView.SCHEDULES && (
          <ScheduleManager 
            schedules={schedules} 
            onAddSchedule={handleAddSchedule} 
            onRemoveSchedule={handleRemoveSchedule}
          />
        )}
      </main>

      <Navigation currentView={currentView} onChangeView={setCurrentView} />
    </div>
  );
};

export default App;
